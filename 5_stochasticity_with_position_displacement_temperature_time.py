# -*- coding: utf-8 -*-
"""5. Definitive.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QSB8V435qXkRTDdT4vMu9PCSdA5VKDKv
"""

import numpy as np
import random
from math import sqrt
import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator
from matplotlib.colors import ListedColormap
from matplotlib.colors import LinearSegmentedColormap

def euclidean_distance(point1, point2):
    return sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)

# Defining initial parameters
N_initial_stemcells = 99
N_initial_neurons = 1
temperature = 28.5          # This is an example. Set it to the value you have
time_steps = 24         # This is an example. Set it to the value you have

# Grid creation for stem cells and neurons
xgrid_stemcell_creation = list(range(-30, 31))
ygrid_stemcell_creation = list(range(-25, 26))
xgrid_creation = list(range(-50, 51))
ygrid_creation = list(range(-25, 26))

# Initial positions
Cells = []
for i in range(N_initial_stemcells):
    Cells.append(['stemcell', random.choice(xgrid_stemcell_creation), random.choice(ygrid_stemcell_creation), 0, random.choice(['L', 'M', 'N'])])

for i in range(N_initial_neurons):
    side_choice = random.choice([-1, 1])
    if side_choice == -1:
        Cells.append(['neuron', random.choice(range(-59, -31)), random.choice(ygrid_creation), 0])
    else:
        Cells.append(['neuron', random.choice(range(31, 59)), random.choice(ygrid_creation), 0])

# Dice roll function to simulate stochasticity in cell behavior
def roll_dice():
    return random.randint(1, 6)

T = temperature
h = 72
HT = h / (.055 * T - .57)
delay = (h / HT)
time_steps = int(time_steps * delay)

l, m, n = [1], [2], [3]
w = int(time_steps / 8)

for i in range(1, w):
    l.append(i * 8 + l[0])
    m.append(i * 8 + m[0])
    n.append(i * 8 + n[0])

initial_positions = {cell[-1]: (cell[1], cell[2]) for cell in Cells}

for i in range(time_steps):
    q = 'U'
    if i in l:
        q = 'L'
    elif i in m:
        q = 'M'
    elif i in n:
        q = 'N'

    A, B, C, D = 25, 25, 25, 25

    for z in list(Cells):  # convert to list to avoid modification issues during iteration
        if 'neuron' in z:
            continue

        pick_random_number = random.randint(1, 100)

        if z[0] == 'stemcell':
            x = random.choice(xgrid_stemcell_creation)
            y = random.choice(ygrid_stemcell_creation)
        else:
            x = random.choice(xgrid_creation)
            y = random.choice(ygrid_creation)

        if pick_random_number <= A:
            Cells.append(['stemcell', x, y, i, q])

        elif A < pick_random_number <= A + B:
            side_choice = random.choice([-1, 1])
            x = random.choice(range(-59, -31)) if side_choice == -1 else random.choice(range(31, 59))
            Cells.append(['neuron', x, y, i])

        elif A + B < pick_random_number <= A + B + C:
            side_choice = random.choice([-1, 1])
            x = random.choice(range(-59, -31)) if side_choice == -1 else random.choice(range(31, 59))
            Cells.append(['neuron', x, y, i])
            Cells.remove(z)

total_stemcells = len([cell for cell in Cells if cell[0] == 'stemcell'])
total_neurons = len([cell for cell in Cells if cell[0] == 'neuron'])


# Extract q values from the cells and map to colors

q_to_value = {
    'L': 0.0,  # Start of gradient
    'M': 0.33,  # Somewhere in the middle
    'N': 0.66,  # Further along
    'U': 1.0   # End of gradient
}
values_stemcell = [q_to_value[cell[4]] for cell in Cells if cell[0] == 'stemcell']

if Cells[0] == "stemcell":
    cell_id = Cells[5]
else:  # it's a neuron
    cell_id = Cells[4]

# Create a custom colormap with your desired colors
colors = [(1, 0, 1), (0, 1, 0), (0, 0, 1), (1, 1, 0)]  # RGB for magenta, green, blue, and yellow
n_bins = [4]  # Discretizes the interpolation into bins
cmap_name = 'custom_div_cmap'
cm = LinearSegmentedColormap.from_list(cmap_name, colors, N=4)
colors_stemcell_gradient = cm(values_stemcell)



#Final grid dfinition
x_stemcell = [p[1] for p in Cells if p[0] == 'stemcell']
y_stemcell = [p[2] for p in Cells if p[0] == 'stemcell']

x_neuron = [p[1] for p in Cells if p[0] == 'neuron']
y_neuron = [p[2] for p in Cells if p[0] == 'neuron']


# Extract q values from the cells and map to colors

q_to_value = {
    'L': 0.0,  # Start of gradient
    'M': 0.33,  # Somewhere in the middle
    'N': 0.66,  # Further along
    'U': 1.0   # End of gradient
}
values_stemcell = [q_to_value[cell[4]] for cell in Cells if cell[0] == 'stemcell']

if Cells[0] == "stemcell":
    cell_id = Cells[5]
else:  # it's a neuron
    cell_id = Cells[4]

# Create a custom colormap with your desired colors
colors = [(1, 0, 1), (0, 1, 0), (0, 0, 1), (1, 1, 0)]  # RGB for magenta, green, blue, and yellow
n_bins = [4]  # Discretizes the interpolation into bins
cmap_name = 'custom_div_cmap'
cm = LinearSegmentedColormap.from_list(cmap_name, colors, N=4)
colors_stemcell_gradient = cm(values_stemcell)

#Final grid dfinition
x_stemcell = [p[1] for p in Cells if p[0] == 'stemcell']
y_stemcell = [p[2] for p in Cells if p[0] == 'stemcell']

x_neuron = [p[1] for p in Cells if p[0] == 'neuron']
y_neuron = [p[2] for p in Cells if p[0] == 'neuron']

# Extract timestamps
timestamps_stemcell = [p[3] for p in Cells if p[0] == 'stemcell']
timestamps_neuron = [p[3] for p in Cells if p[0] == 'neuron']

# Create the figure and the subplot
fig, ax = plt.subplots(figsize=(10, 10))  # Using a square figure size

# Define the size of the square
square_size = 4

# Scatter plot of cell positions using timestamp values for color
# Here, the `c` parameter is used to pass the timestamp values. The `cmap` parameter defines the colormap to be used.
sc_stemcell = ax.scatter(x_stemcell, y_stemcell, c=timestamps_stemcell, cmap='Blues', label='Stemcells', s=square_size**2)
sc_neuron = ax.scatter(x_neuron, y_neuron, c=timestamps_neuron, cmap='Reds', label='Neurons', s=square_size**2)

# Adding colorbars
cbar_stemcell = fig.colorbar(sc_stemcell, ax=ax, orientation='vertical')
cbar_neuron = fig.colorbar(sc_neuron, ax=ax, orientation='vertical', pad=0.1)

cbar_stemcell.set_label('Stemcell Timestamps')
cbar_neuron.set_label('Neuron Timestamps')

# Scatter plot of cell positions
#ax.scatter(x_stemcell, y_stemcell, c=colors_stemcell_gradient, label='Stemcells', s=square_size**2)
#ax.scatter(x_neuron, y_neuron, c='red', label='Neurons', s=square_size**2)

# Set the limits of the plot
ax.set_xlim(-60, 60)
ax.set_ylim(-30, 30)

# Set the ticks of the axes
ticks_x = range(-60, 61, 10)
ticks_y = range(-30, 31, 10)
ax.set_xticks(ticks_x)
ax.set_yticks(ticks_y)

# Activate minor ticks
plt.minorticks_on()

# Set the location of the minor ticks at each integer
ax.xaxis.set_minor_locator(MultipleLocator(1))
ax.yaxis.set_minor_locator(MultipleLocator(1))

# Adjust minor ticks on the grid
plt.grid(True)
plt.grid(which='minor', linestyle=':', linewidth='0.5')

# Show the legend

plt.title("Stochastics with condition on position, displacement and temperature")


# Show the plot
plt.show()
# -*- coding: utf-8 -*-
"""1_stochasticity_without_conditioning_positionv2_4scenarios_Sctag_colored.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VInL9KktYXWe6IqA2dGlwn1-7so3iWzu
"""

# Load packages
import pandas as pd
import seaborn as sns
import numpy as np
#Import functions to add secuences
from statistics import median
from math import isnan
from itertools import filterfalse
#Import functions to more stats
import math
import statistics
#Import functions to add secuences
from numpy import random
from statistics import median
from math import sqrt
from math import isnan
from itertools import filterfalse
from pandas._libs.algos import is_monotonic
import random
import copy
import numpy as np
#Import functions to create the figure
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator
from matplotlib.colors import ListedColormap
from matplotlib.colors import LinearSegmentedColormap

# Constants representing initial cellular conditions
N_initial = 100
N_initial_stemcells = int(0.99 * N_initial)
N_initial_neurons = int(0.01 * N_initial)

xgrid = list(range(-60, 61))
ygrid = list(range(-30, 31))

xgrid_creation = list(range(-50, 51))
ygrid_creation = list(range(-25, 26))

# Initial cell positions
Cells = []
for i in range(N_initial_stemcells):
    Cells.append(['stemcell', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),0,random.choice(['L','M','N'])])
for i in range(N_initial_neurons):
    Cells.append(['neuron', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),0])

time_steps = 72 #real time
w=int((time_steps)/8) #timecycle of differentiation

initial_cells = (Cells)
print (initial_cells)

# Dice roll function to simulate stochasticity in cell behavior

def roll_dice():
    return random.randint(1, 6)

total_stemcells = N_initial_stemcells
total_neurons = N_initial_neurons


l=[1]                               #associated list of timepoints for division of group "L" "M" "N"
m=[2]
n=[3]


for i in range(1, w):
   l.append(i*8+l[0])
   m.append(i*8+m[0])
   n.append(i*8+n[0])

print(l)
print(m)
print(n)

for i in range(time_steps):                 #selecting timepoints for execution

 if i in l:
      q ='L'
 elif i in m:
      q ='M'
 elif i in n:
      q ='N'
 else:
      q='U'

 for z in Cells:
     if 'neuron' in z:
        continue
     elif z[0]=='stemcell' and z[4]==q:
        dice_result = roll_dice()
        if dice_result in [1]:
           Cells.append(['stemcell', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),i,q])
        elif dice_result in [2]:
           Cells.append(['neuron', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),i])
        elif dice_result in [3]:
           Cells.append(['neuron', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),i])
           Cells.append(['neuron', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),(i)])
           Cells.remove(z)
        elif dice_result in [4]:
           continue
        elif dice_result in [5]:
           v=random.randint(0, 1)
           if v==0:
             Cells.append(['stemcell', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),i,q])
           else:
             Cells.append(['neuron', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),i])
        elif dice_result in [6]:
           g=random.randint(0, 1)
           if g==0:
             Cells.append(['neuron', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),i])
             Cells.append(['neuron', np.random.choice(xgrid_creation), np.random.choice(ygrid_creation),(i)])
             Cells.remove(z)
           else:
            continue
     else:
        continue

  # Update the total counts for the next iteration
total_stemcells = len([cell for cell in Cells if cell[0] == 'stemcell'])
total_neurons = len([cell for cell in Cells if cell[0] == 'neuron'])

print(total_stemcells)
print(total_neurons)

# Print the final state of Cells after 1000 iterations
#print(Cells)
print(f"Number of neurons at timestep {i}: {len([cell for cell in Cells if cell[0] == 'neuron'])}")

final_cells = (Cells)
#print (final_cells)

total_cells= total_stemcells+ total_neurons
print(total_cells)
print(Cells)

# Extract q values from the cells and map to colors

q_to_value = {
    'L': 0.0,  # Start of gradient
    'M': 0.33,  # Somewhere in the middle
    'N': 0.66,  # Further along
    'U': 1.0   # End of gradient
}
values_stemcell = [q_to_value[cell[4]] for cell in Cells if cell[0] == 'stemcell']

if Cells[0] == "stemcell":
    cell_id = Cells[5]
else:  # it's a neuron
    cell_id = Cells[4]

# Create a custom colormap with your desired colors
colors = [(1, 0, 1), (0, 1, 0), (0, 0, 1), (1, 1, 0)]  # RGB for magenta, green, blue, and yellow
n_bins = [4]  # Discretizes the interpolation into bins
cmap_name = 'custom_div_cmap'
cm = LinearSegmentedColormap.from_list(cmap_name, colors, N=4)
colors_stemcell_gradient = cm(values_stemcell)

#Final grid dfinition
x_stemcell = [p[1] for p in Cells if p[0] == 'stemcell']
y_stemcell = [p[2] for p in Cells if p[0] == 'stemcell']

x_neuron = [p[1] for p in Cells if p[0] == 'neuron']
y_neuron = [p[2] for p in Cells if p[0] == 'neuron']

# Extract timestamps
timestamps_stemcell = [p[3] for p in Cells if p[0] == 'stemcell']
timestamps_neuron = [p[3] for p in Cells if p[0] == 'neuron']

# Create the figure and the subplot
fig, ax = plt.subplots(figsize=(10, 10))  # Using a square figure size

# Define the size of the square
square_size = 4

# Scatter plot of cell positions using timestamp values for color
# Here, the `c` parameter is used to pass the timestamp values. The `cmap` parameter defines the colormap to be used.
sc_stemcell = ax.scatter(x_stemcell, y_stemcell, c=timestamps_stemcell, cmap='Blues', label='Stemcells', s=square_size**2)
sc_neuron = ax.scatter(x_neuron, y_neuron, c=timestamps_neuron, cmap='Reds', label='Neurons', s=square_size**2)

# Adding colorbars
cbar_stemcell = fig.colorbar(sc_stemcell, ax=ax, orientation='vertical')
cbar_neuron = fig.colorbar(sc_neuron, ax=ax, orientation='vertical', pad=0.1)

cbar_stemcell.set_label('Stemcell Timestamps')
cbar_neuron.set_label('Neuron Timestamps')

# Scatter plot of cell positions
#ax.scatter(x_stemcell, y_stemcell, c=colors_stemcell_gradient, label='Stemcells', s=square_size**2)
#ax.scatter(x_neuron, y_neuron, c='red', label='Neurons', s=square_size**2)

# Set the limits of the plot
ax.set_xlim(-60, 60)
ax.set_ylim(-30, 30)

# Set the ticks of the axes
ticks_x = range(-60, 61, 10)
ticks_y = range(-30, 31, 10)
ax.set_xticks(ticks_x)
ax.set_yticks(ticks_y)

# Activate minor ticks
plt.minorticks_on()

# Set the location of the minor ticks at each integer
ax.xaxis.set_minor_locator(MultipleLocator(1))
ax.yaxis.set_minor_locator(MultipleLocator(1))

# Adjust minor ticks on the grid
plt.grid(True)
plt.grid(which='minor', linestyle=':', linewidth='0.5')

# Show the legend
plt.title("Stochastics with no condition on position")


# Show the plot
plt.show()

